"use client";

import React, { useEffect, useRef, useState } from "react";

type GameKeys = {
  left: boolean;
  right: boolean;
  space: boolean;
  isFiring: boolean;
  burstCount: number;
  burstLimit: number;
  burstCooldown: number;
};

type GameState = {
  score: number;
  isStarted: boolean;
  isGameOver: boolean;
  lastTime: number;
  deltaTime: number;
  player: Player | null;
  lasers: Laser[];
  enemies: Enemy[];
  activeEnemyCount: number;
  enemyLasers: Laser[];
  explosions: Explosion[];
  enemyGlobalShotTimer: number;
  keys: GameKeys;
};

class GameObject {
  x: number;
  y: number;
  radius: number;
  color: string;
  constructor(x: number, y: number, radius: number, color: string) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.color = color;
  }
}

class Explosion extends GameObject {
  particles: Array<{
    x: number;
    y: number;
    vx: number;
    vy: number;
    radius: number;
    color: string;
    initialRadius: number;
  }>;
  lifetime: number;
  timeElapsed: number;
  constructor(x: number, y: number) {
    super(x, y, 0, "white");
    this.particles = [];
    this.lifetime = 0.5;
    this.timeElapsed = 0;
    for (let i = 0; i < randomRange(10, 15); i++) {
      const angle = randomRange(0, 360);
      const speed = randomRange(50, 150);
      const radius = randomRange(1, 3);
      this.particles.push({
        x,
        y,
        vx: Math.cos(degToRad(angle)) * speed,
        vy: Math.sin(degToRad(angle)) * speed,
        radius,
        color: Math.random() > 0.5 ? "#ffffff" : "#dddddd",
        initialRadius: radius,
      });
    }
  }
  update(dt: number) {
    this.timeElapsed += dt;
    const fadeRatio = 1 - this.timeElapsed / this.lifetime;
    this.particles.forEach((p) => {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.radius = p.initialRadius * fadeRatio;
    });
  }
  draw(ctx: CanvasRenderingContext2D) {
    ctx.shadowBlur = 5;
    this.particles.forEach((p) => {
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;
  }
  isFinished() {
    return this.timeElapsed >= this.lifetime;
  }
}

class Laser extends GameObject {
  vx: number;
  vy: number;
  constructor(x: number, y: number, vx: number, vy: number, color: string) {
    super(x, y, 2, color);
    this.vx = vx;
    this.vy = vy;
  }
  update(dt: number) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
  }
  draw(ctx: CanvasRenderingContext2D) {
    ctx.fillStyle = this.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = this.color;
    ctx.fillRect(this.x - 1, this.y - 5, 2, 10);
    ctx.shadowBlur = 0;
  }
}

class Player extends GameObject {
  speed: number;
  constructor(x: number, y: number) {
    super(x, y, 15, "white");
    this.speed = 250;
  }
  update(dt: number, keys: GameKeys, canvas: HTMLCanvasElement) {
    if (keys.left) {
      this.x -= this.speed * dt;
    }
    if (keys.right) {
      this.x += this.speed * dt;
    }
    this.x = Math.max(
      this.radius,
      Math.min(canvas.width - this.radius, this.x)
    );
  }
  draw(ctx: CanvasRenderingContext2D) {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y - this.radius);
    ctx.lineTo(this.x - this.radius * 1.5, this.y + this.radius);
    ctx.lineTo(this.x + this.radius * 1.5, this.y + this.radius);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#a1a1aa";
    ctx.beginPath();
    ctx.arc(this.x, this.y + 2, this.radius / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  shoot(game: GameState) {
    if (
      game.keys.burstCount >= game.keys.burstLimit ||
      game.keys.burstCooldown > 0
    ) {
      return;
    }
    game.keys.burstCount += 1;
    game.keys.burstCooldown = 0.03;
    const LASER_SPEED = 500;
    let vx = 0;
    let vy = 0;
    if (game.keys.burstCount === 1) {
      const straightAngle = degToRad(90);
      vx = Math.cos(straightAngle) * LASER_SPEED;
      vy = -Math.sin(straightAngle) * LASER_SPEED;
    } else {
      const START_ANGLE = degToRad(90 - 40);
      const END_ANGLE = degToRad(90 + 40);
      const angle = randomRange(START_ANGLE, END_ANGLE);
      vx = Math.cos(angle) * LASER_SPEED;
      vy = -Math.sin(angle) * LASER_SPEED;
    }
    game.lasers.push(new Laser(this.x, this.y - this.radius, vx, vy, "white"));
  }
}

class Enemy extends GameObject {
  vx: number;
  vy: number;
  is404: boolean;
  borderRadius: number;
  fillColor: string;
  outlineColor: string;
  constructor(x: number, y: number, vx: number, vy: number, is404: boolean) {
    super(x, y, SHIP_RADIUS, "white");
    this.vx = vx;
    this.vy = vy;
    this.is404 = is404;
    this.borderRadius = 4; // closer to design's rounded squares
    this.fillColor = is404
      ? "rgba(255, 255, 255, 1)"
      : "rgba(255, 255, 255, 0.20)";
    this.outlineColor = "#ffffff";
  }
  update(dt: number, game: GameState, canvas: HTMLCanvasElement) {
    if (game.isStarted && this.is404) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
        this.vx *= -1;
      }
    }
  }
  draw(ctx: CanvasRenderingContext2D) {
    const halfSize = this.radius;
    const r = this.borderRadius;
    ctx.beginPath();
    ctx.moveTo(this.x - halfSize + r, this.y - halfSize);
    ctx.lineTo(this.x + halfSize - r, this.y - halfSize);
    ctx.arcTo(
      this.x + halfSize,
      this.y - halfSize,
      this.x + halfSize,
      this.y - halfSize + r,
      r
    );
    ctx.lineTo(this.x + halfSize, this.y + halfSize - r);
    ctx.arcTo(
      this.x + halfSize,
      this.y + halfSize,
      this.x + halfSize - r,
      this.y + halfSize,
      r
    );
    ctx.lineTo(this.x - halfSize + r, this.y + halfSize);
    ctx.arcTo(
      this.x - halfSize,
      this.y + halfSize,
      this.x - halfSize,
      this.y + halfSize - r,
      r
    );
    ctx.lineTo(this.x - halfSize, this.y - halfSize + r);
    ctx.arcTo(
      this.x - halfSize,
      this.y - halfSize,
      this.x - halfSize + r,
      this.y - halfSize,
      r
    );
    ctx.closePath();
    ctx.fillStyle = this.fillColor;
    ctx.fill();
    ctx.strokeStyle = this.outlineColor;
    ctx.lineWidth = 1.25;
    ctx.stroke();
  }
  shoot(game: GameState) {
    if (!game.player || !this.is404) return;
    const LASER_SPEED = randomRange(150, 200);
    const dx = (game.player?.x ?? 0) - this.x;
    const dy = (game.player?.y ?? 0) - this.y;
    const angle = Math.atan2(dy, dx);
    const vx = Math.cos(angle) * LASER_SPEED;
    const vy = Math.sin(angle) * LASER_SPEED;
    game.enemyLasers.push(
      new Laser(this.x, this.y + this.radius, vx, vy, "#e5e5e5")
    );
  }
}

const degToRad = (degrees: number) => degrees * (Math.PI / 180);
const randomRange = (min: number, max: number) =>
  Math.random() * (max - min) + min;

const COLS = 16;
const ROWS = 8;
const SHIP_RADIUS = 12;
const SHIP_SIZE = SHIP_RADIUS * 2; // 64px
const GRID_GAP = 4; // equal gap between ships
const GRID_BORDER_GAP = 8; // gap around the grid
const SHAPE_404_PATTERN: number[] = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1,
  0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

const NotFound: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const scoreRef = useRef<HTMLDivElement | null>(null);
  const [score, setScore] = useState<number>(0);
  const [overlayVisible, setOverlayVisible] = useState<boolean>(true);
  const [overlayMode, setOverlayMode] = useState<"intro" | "gameover" | "win">(
    "intro"
  );
  const requestIdRef = useRef<number | null>(null);
  const gameRef = useRef<GameState | null>(null);
  const [gridMetrics, setGridMetrics] = useState<{
    startX: number;
    startY: number;
    spacingX: number;
    spacingY: number;
    totalGridWidth: number;
    totalGridHeight: number;
  } | null>(null);

  const computeGridMetrics = (
    canvas: HTMLCanvasElement
  ): {
    startX: number;
    startY: number;
    spacingX: number;
    spacingY: number;
    totalGridWidth: number;
    totalGridHeight: number;
  } => {
    const availableWidth = canvas.width - GRID_BORDER_GAP * 2;
    const availableHeight = canvas.height * 0.5;
    const totalShipsWidth = COLS * SHIP_SIZE;
    const gapX = (availableWidth - totalShipsWidth) / (COLS - 1);
    const spacingX = Math.max(GRID_GAP, gapX);
    const totalGridWidth = totalShipsWidth + spacingX * (COLS - 1);
    const startX = (canvas.width - totalGridWidth) / 2 + SHIP_RADIUS;

    const totalShipsHeight = ROWS * SHIP_SIZE;
    const gapY = (availableHeight - totalShipsHeight) / (ROWS - 1);
    const spacingY = Math.max(GRID_GAP, gapY);
    const totalGridHeight = totalShipsHeight + spacingY * (ROWS - 1);
    const startY = canvas.height * 0.25 - totalGridHeight / 2 + SHIP_RADIUS;

    return {
      startX,
      startY,
      spacingX,
      spacingY,
      totalGridWidth,
      totalGridHeight,
    };
  };

  const handleResize = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const game = gameRef.current;
    if (!game || game.isStarted || game.isGameOver) return;
    if (game.player) {
      game.player.x = canvas.width / 2;
      game.player.y = canvas.height - 50;
    }
    repositionStaticEnemies(canvas);
    draw();
  };

  const repositionStaticEnemies = (canvas: HTMLCanvasElement) => {
    const game = gameRef.current;
    if (!game) return;
    const {
      startX,
      startY,
      spacingX,
      spacingY,
      totalGridWidth,
      totalGridHeight,
    } = computeGridMetrics(canvas);
    setGridMetrics({
      startX,
      startY,
      spacingX,
      spacingY,
      totalGridWidth,
      totalGridHeight,
    });
    let enemyIndex = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (game.enemies[enemyIndex]) {
          game.enemies[enemyIndex].x = startX + c * (SHIP_SIZE + spacingX);
          game.enemies[enemyIndex].y = startY + r * (SHIP_SIZE + spacingY);
        }
        enemyIndex += 1;
      }
    }
  };

  const initializeGame = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const newGame: GameState = {
      score: 0,
      isStarted: false,
      isGameOver: false,
      lastTime: 0,
      deltaTime: 0,
      player: null,
      lasers: [],
      enemies: [],
      activeEnemyCount: 0,
      enemyLasers: [],
      explosions: [],
      enemyGlobalShotTimer: 3,
      keys: {
        left: false,
        right: false,
        space: false,
        isFiring: false,
        burstCount: 0,
        burstLimit: 10,
        burstCooldown: 0,
      },
    };
    gameRef.current = newGame;
    newGame.player = new Player(canvas.width / 2, canvas.height - 50);
    const {
      startX,
      startY,
      spacingX,
      spacingY,
      totalGridWidth,
      totalGridHeight,
    } = computeGridMetrics(canvas);
    setGridMetrics({
      startX,
      startY,
      spacingX,
      spacingY,
      totalGridWidth,
      totalGridHeight,
    });
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const index = r * COLS + c;
        const is404Active = SHAPE_404_PATTERN[index] === 1;
        const x = startX + c * (SHIP_SIZE + spacingX);
        const y = startY + r * (SHIP_SIZE + spacingY);
        const enemy = new Enemy(x, y, 0, 0, is404Active);
        newGame.enemies.push(enemy);
        if (is404Active) newGame.activeEnemyCount += 1;
      }
    }
    setScore(0);
    setOverlayMode("intro");
    setOverlayVisible(true);
    draw();
  };

  const startGame = () => {
    const game = gameRef.current;
    const canvas = canvasRef.current;
    if (!game || !canvas) return;
    if (!game.isStarted) {
      game.isStarted = true;
      setOverlayVisible(false);
      // Remove passive (20% opacity) background ships immediately on start
      game.enemies = game.enemies.filter((enemy) => enemy.is404);
      game.enemies.forEach((enemy) => {
        if (enemy.is404) {
          enemy.vx = randomRange(-80, 80);
          enemy.vy = randomRange(30, 60);
        }
      });
      game.lastTime = performance.now();
      requestIdRef.current = requestAnimationFrame(gameLoop);
    }
  };

  const gameOver = (mode: "gameover" | "win") => {
    const game = gameRef.current;
    if (!game) return;
    if (!game.isGameOver) {
      game.isGameOver = true;
      game.isStarted = false;
      setOverlayMode(mode);
      setOverlayVisible(true);
    }
  };

  const update = (dt: number) => {
    const canvas = canvasRef.current;
    const game = gameRef.current;
    if (!canvas || !game) return;
    if (game.isGameOver || !game.isStarted) return;
    if (game.player) {
      game.player.update(dt, game.keys, canvas);
    }
    if (game.keys.burstCooldown > 0) {
      game.keys.burstCooldown -= dt;
      if (game.keys.burstCooldown <= 0) game.keys.burstCooldown = 0;
    }
    if (
      game.keys.space &&
      game.keys.burstCount < game.keys.burstLimit &&
      game.keys.burstCooldown === 0 &&
      game.player
    ) {
      game.player.shoot(game);
    }
    if (!game.keys.space) {
      game.keys.burstCount = 0;
    }
    game.enemyGlobalShotTimer -= dt;
    if (game.activeEnemyCount > 0 && game.enemyGlobalShotTimer <= 0) {
      const activeEnemies = game.enemies.filter((e) => e.is404);
      if (activeEnemies.length > 0) {
        const randomIndex = Math.floor(Math.random() * activeEnemies.length);
        const shootingEnemy = activeEnemies[randomIndex];
        shootingEnemy.shoot(game);
        game.enemyGlobalShotTimer = randomRange(1.5, 3);
      }
    }
    game.lasers.forEach((laser) => laser.update(dt));
    game.lasers = game.lasers.filter(
      (l) => l.y > -10 && l.x > -10 && l.x < canvas.width + 10
    );
    game.enemies.forEach((enemy) => enemy.update(dt, game, canvas));
    game.enemies = game.enemies.filter((e) => e.y < canvas.height + 20);
    game.enemyLasers.forEach((laser) => laser.update(dt));
    game.enemyLasers = game.enemyLasers.filter(
      (l) => l.y < canvas.height + 10 && l.x > -10 && l.x < canvas.width + 10
    );
    game.explosions.forEach((e) => e.update(dt));
    game.explosions = game.explosions.filter((e) => !e.isFinished());
    for (let lIndex = game.lasers.length - 1; lIndex >= 0; lIndex--) {
      const laser = game.lasers[lIndex];
      for (let eIndex = game.enemies.length - 1; eIndex >= 0; eIndex--) {
        const enemy = game.enemies[eIndex];
        const distance = Math.hypot(laser.x - enemy.x, laser.y - enemy.y);
        if (distance < laser.radius + enemy.radius) {
          game.explosions.push(new Explosion(enemy.x, enemy.y));
          game.lasers.splice(lIndex, 1);
          if (enemy.is404) {
            game.activeEnemyCount -= 1;
            game.score += 10;
          } else {
            game.score += 1;
          }
          setScore(game.score);
          game.enemies.splice(eIndex, 1);
          break;
        }
      }
    }
    if (game.player) {
      for (let lIndex = game.enemyLasers.length - 1; lIndex >= 0; lIndex--) {
        const laser = game.enemyLasers[lIndex];
        const distance = Math.hypot(
          laser.x - game.player.x,
          laser.y - game.player.y
        );
        if (distance < laser.radius + game.player.radius) {
          game.explosions.push(new Explosion(game.player.x, game.player.y));
          gameOver("gameover");
          return;
        }
      }
      for (const enemy of game.enemies) {
        const distance = Math.hypot(
          (game.player?.x ?? 0) - enemy.x,
          (game.player?.y ?? 0) - enemy.y
        );
        if (distance < (game.player?.radius ?? 0) + enemy.radius) {
          game.explosions.push(new Explosion(game.player.x, game.player.y));
          game.explosions.push(new Explosion(enemy.x, enemy.y));
          gameOver("gameover");
          return;
        }
      }
    }
    if (game.activeEnemyCount === 0) {
      setOverlayMode("win");
      gameOver("win");
    }
  };

  const draw = () => {
    const canvas = canvasRef.current;
    const game = gameRef.current;
    if (!canvas || !game) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    game.lasers.forEach((laser) => laser.draw(ctx));
    game.enemies.forEach((enemy) => enemy.draw(ctx));
    game.enemyLasers.forEach((laser) => laser.draw(ctx));
    if (game.player) game.player.draw(ctx);
    game.explosions.forEach((e) => e.draw(ctx));
  };

  const gameLoop = (currentTime: number) => {
    const game = gameRef.current;
    if (!game) return;
    if (game.isGameOver) return;
    game.deltaTime = (currentTime - game.lastTime) / 1000;
    game.lastTime = currentTime;
    update(game.deltaTime);
    draw();
    requestIdRef.current = requestAnimationFrame(gameLoop);
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    const game = gameRef.current;
    if (!game) return;
    if (e.code === "ArrowLeft") {
      game.keys.left = true;
    } else if (e.code === "ArrowRight") {
      game.keys.right = true;
    } else if (e.code === "Space") {
      e.preventDefault();
      if (game.isStarted && !game.isGameOver) {
        game.keys.space = true;
      } else if (!game.isStarted && !game.isGameOver) {
        startGame();
      } else if (game.isGameOver) {
        initializeGame();
        startGame();
      }
    }
  };

  const handleKeyUp = (e: KeyboardEvent) => {
    const game = gameRef.current;
    if (!game) return;
    if (e.code === "ArrowLeft") {
      game.keys.left = false;
    } else if (e.code === "ArrowRight") {
      game.keys.right = false;
    } else if (e.code === "Space") {
      game.keys.space = false;
    }
  };

  useEffect(() => {
    initializeGame();
    window.addEventListener("resize", handleResize);
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("resize", handleResize);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      if (requestIdRef.current) cancelAnimationFrame(requestIdRef.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleStartClick = () => {
    startGame();
  };

  return (
    <div className="relative h-screen w-screen overflow-hidden bg-black">
      <div
        ref={scoreRef}
        className="fixed top-5 right-5 z-10 rounded-md bg-black/50 px-2 py-1 text-white"
        aria-live="polite"
      >
        Score: {score}
      </div>
      <canvas
        ref={canvasRef}
        className="fixed inset-0 h-full w-full"
        aria-label="Galactic Shooter 404 game canvas"
        role="img"
      />
      {!gameRef.current?.isStarted && gridMetrics && (
        <div
          className="pointer-events-none fixed z-10"
          style={{
            left: `${gridMetrics.startX - SHIP_RADIUS}px`,
            top: `${gridMetrics.startY - SHIP_RADIUS}px`,
            width: `${gridMetrics.totalGridWidth + SHIP_SIZE}px`,
            height: `${gridMetrics.totalGridHeight + SHIP_SIZE}px`,
            display: "grid",
            gridTemplateColumns: `repeat(${COLS}, ${SHIP_SIZE}px)`,
            gridTemplateRows: `repeat(${ROWS}, ${SHIP_SIZE}px)`,
            gap: `${gridMetrics.spacingX}px ${gridMetrics.spacingY}px`,
          }}
          aria-hidden
        >
          {Array.from({ length: ROWS * COLS }).map((_, idx) => {
            const isActive = SHAPE_404_PATTERN[idx] === 1;
            return (
              <div
                key={idx}
                className="rounded"
                style={{
                  borderRadius: `${4}px`,
                  backgroundColor: isActive
                    ? "rgba(255,255,255,1)"
                    : "rgba(255,255,255,0.20)",
                  boxShadow: `inset 0 0 0 1.25px #ffffff`,
                  width: `${SHIP_SIZE}px`,
                  height: `${SHIP_SIZE}px`,
                }}
              />
            );
          })}
        </div>
      )}
      {overlayVisible && (
        <div
          className="fixed inset-0 z-20 box-border flex h-full w-full flex-col items-center justify-center bg-black/80 p-5 text-center"
          role="dialog"
          aria-modal="true"
          tabIndex={0}
        >
          {overlayMode === "intro" && (
            <div className="max-w-xl text-white">
              <h1 className="mb-2 text-3xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,255,255,1)]">
                404: Ships Not Found
              </h1>
              <p className="message-text mb-5 text-lg text-zinc-400">
                The central command group has broken ranks. Eliminate the{" "}
                <span className="font-semibold text-white">active</span> ships
                to clear the error.
              </p>
              <div className="message-instructions rounded-md border border-zinc-700 bg-zinc-900 p-4 text-white">
                Use{" "}
                <span className="key-hint inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  SPACE
                </span>{" "}
                to start and shoot. Use
                <span className="key-hint ml-2 inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  ←
                </span>{" "}
                and
                <span className="key-hint ml-2 inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  →
                </span>{" "}
                to move.
              </div>
              <p className="mt-5 text-lg text-zinc-400">
                Press{" "}
                <span className="key-hint inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  SPACE
                </span>{" "}
                to Engage!
              </p>
              <button
                onClick={handleStartClick}
                className="mt-6 rounded-md bg-white px-4 py-2 font-semibold text-black hover:bg-zinc-200 focus:outline-none focus:ring-2 focus:ring-white"
                aria-label="Start game"
              >
                Start
              </button>
            </div>
          )}
          {overlayMode === "gameover" && (
            <div className="max-w-xl text-white">
              <h1 className="message-title mb-2 text-3xl font-bold text-white">
                SYSTEM FAILURE
              </h1>
              <p className="message-text mb-5 text-lg text-zinc-400">
                Final Score: {score}. That&apos;s tough, bro.
              </p>
              <p className="message-text text-lg text-zinc-400">
                Press{" "}
                <span className="key-hint inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  SPACE
                </span>{" "}
                to Restart.
              </p>
            </div>
          )}
          {overlayMode === "win" && (
            <div className="max-w-xl text-white">
              <h1 className="message-title mb-2 text-3xl font-bold text-white">
                SYSTEM RESTORED
              </h1>
              <p className="message-text mb-5 text-lg text-zinc-400">
                Error 404 cleared. The remaining ships await orders. Final
                Score: {score}. Big W!
              </p>
              <p className="message-text text-lg text-zinc-400">
                Press{" "}
                <span className="key-hint inline-block rounded border border-white bg-zinc-700 px-2 py-1 font-mono">
                  SPACE
                </span>{" "}
                to Restart.
              </p>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default NotFound;
