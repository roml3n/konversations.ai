<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Shooter - 404 Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Pure Black */
            color: #e5e5e5; /* Light gray text */
            /* Full page setup */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            margin: 0;
            overflow: hidden;
            position: relative; /* Needed for absolute/fixed children */
        }

        canvas {
            display: block;
            /* Canvas covers the entire viewport */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #score-display {
            position: fixed; /* Fixed position to stick to the full page viewport */
            top: 20px;
            right: 20px;
            font-size: 1.2rem;
            font-weight: 700;
            color: white; /* White for score */
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 6px;
        }

        #message-overlay {
            position: fixed; /* Fixed position to cover the full page viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            padding: 20px;
            box-sizing: border-box;
        }

        .message-title {
            font-size: 2.5rem;
            color: white; /* White for title */
            margin-bottom: 10px;
            text-shadow: 0 0 10px white;
        }

        .message-text {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #a1a1aa; /* Gray */
        }
        
        .message-instructions {
            font-size: 1rem;
            line-height: 1.6;
            color: white;
            padding: 15px;
            background-color: #171717;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .key-hint {
            font-family: monospace;
            background-color: #333; /* Darker key hint */
            color: white;
            padding: 5px 10px;
            border: 1px solid white; /* White outline */
            border-radius: 5px;
            margin: 0 5px;
            display: inline-block;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .message-title {
                font-size: 2rem;
            }
            .message-text {
                font-size: 1rem;
            }
            .message-instructions {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

    <div id="score-display">Score: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div id="message-overlay">
        <!-- Initial content will be set by JS -->
    </div>

<!-- Compiled JavaScript from game.ts -->
<script>
    /**
     * Game logic for the Galactic Shooter (404 Grid Edition).
     */

    // --- Global Constants ---

    // Get required DOM elements
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    const SCORE_DISPLAY = document.getElementById('score-display');
    const OVERLAY = document.getElementById('message-overlay');

    // Game state initialization
    let game = {
        score: 0,
        isStarted: false,
        isGameOver: false,
        lastTime: 0,
        deltaTime: 0,
        player: null,
        lasers: [],
        enemies: [],
        activeEnemyCount: 0, // Track only the "404" ships
        enemyLasers: [],
        explosions: [], 
        enemyGlobalShotTimer: 3, 
        keys: { left: false, right: false, space: false, isFiring: false, burstCount: 0, burstLimit: 10, burstCooldown: 0 }
    };
    
    // --- 404 Grid Pattern (16x8 Grid) ---
    // 1 = Active 404 ship (darker fill), 0 = Passive Grid ship (lighter fill)
    const COLS = 16; 
    const ROWS = 8;
    const SHAPE_404_PATTERN = [
        // R1
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // R2 - 404 starts here
        0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 
        // R3
        0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,
        // R4
        1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 
        // R5
        0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0,
        // R6
        0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 
        // R7
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // R8
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    // --- Utility Functions ---

    /**
     * Converts degrees to radians.
     * @param degrees The angle in degrees.
     * @returns The angle in radians.
     */
    function degToRad(degrees) {
        return degrees * (Math.PI / 180);
    }

    /**
     * Generates a random number within a range [min, max).
     * @param min The inclusive minimum value.
     * @param max The exclusive maximum value.
     * @returns A random number between min and max.
     */
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    /**
     * Helper to reposition the static enemy grid based on new canvas dimensions.
     * This is crucial when the window is resized before the game starts.
     */
    function repositionStaticEnemies() {
        // --- TIGHT GRID PARAMETERS ---
        const shipRadius = 7.4; // 14.8px width
        const spacingX = CANVAS.width / (COLS + 3); // 16 columns + 3 padding spaces
        const spacingY = 20; // Slightly more vertical spacing for the 14.8px ship size

        // Vertical Centering: Aim for 25% down from the top (upper quarter)
        const totalGridHeight = ROWS * spacingY;
        const gridCenterY = totalGridHeight / 2;
        const desiredScreenY = CANVAS.height * 0.25; 
        const startY = desiredScreenY - gridCenterY;
        // -------------------------
        
        let enemyIndex = 0;
        
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Ships are stored sequentially (row by row)
                if (game.enemies[enemyIndex]) {
                    game.enemies[enemyIndex].x = spacingX * (c + 1.5); // Use 1.5 to center the grid slightly better
                    game.enemies[enemyIndex].y = startY + spacingY * r;
                }
                enemyIndex++;
            }
        }
    }

    /**
     * Resizes the canvas to fit the full window size.
     */
    function resizeCanvas() {
        // Use window dimensions for full-screen experience
        CANVAS.width = window.innerWidth;
        CANVAS.height = window.innerHeight;

        // If the game is in the static waiting state, re-align the ships and player
        if (!game.isStarted && !game.isGameOver) {
             // Reposition Player
             if (game.player) {
                game.player.x = CANVAS.width / 2;
                // Keep player 50px from the bottom
                game.player.y = CANVAS.height - 50; 
             }
             
             // Reposition Enemies to maintain the grid ratio
             repositionStaticEnemies();
             
             // Must redraw immediately to show the updated positions
             draw(); 
        }
    }

    window.addEventListener('resize', resizeCanvas); // Attach resize listener

    // --- Game Entities (Classes) ---

    /** Base class for all drawable objects in the game. */
    class GameObject {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
        }

        // draw method is overridden in sub-classes
    }

    /** Represents a temporary pop explosion effect. */
    class Explosion extends GameObject {
        constructor(x, y) {
            super(x, y, 0, 'white'); 
            this.particles = [];
            this.lifetime = 0.5; // seconds
            this.timeElapsed = 0;

            // Create 10-15 particles
            for (let i = 0; i < randomRange(10, 15); i++) {
                const angle = randomRange(0, 360);
                const speed = randomRange(50, 150);
                const radius = randomRange(1, 3);
                this.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(degToRad(angle)) * speed,
                    vy: Math.sin(degToRad(angle)) * speed,
                    radius: radius,
                    color: (Math.random() > 0.5) ? '#ffffff' : '#dddddd', 
                    initialRadius: radius
                });
            }
        }

        update(dt) {
            this.timeElapsed += dt;

            // Update particle positions and fade radius
            const fadeRatio = 1 - (this.timeElapsed / this.lifetime);
            
            this.particles.forEach(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                // Shrink the radius as it fades
                p.radius = p.initialRadius * fadeRatio;
            });
        }

        draw() {
            CTX.shadowBlur = 5;
            this.particles.forEach(p => {
                CTX.fillStyle = p.color;
                CTX.shadowColor = p.color;
                CTX.beginPath();
                CTX.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                CTX.fill();
            });
            CTX.shadowBlur = 0;
        }

        isFinished() {
            return this.timeElapsed >= this.lifetime;
        }
    }


    /** Represents a laser projectile fired by the player or an enemy. */
    class Laser extends GameObject {
        constructor(x, y, vx, vy, color) {
            super(x, y, 2, color);
            this.vx = vx;
            this.vy = vy;
        }

        /**
         * Updates the laser's position based on delta time.
         * @param dt Delta time (time elapsed since last frame) in seconds.
         */
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
        }

        /** Draws the laser as a vertical line with a glow effect. */
        draw() {
            // Draw the laser rectangle
            CTX.fillStyle = this.color;
            
            // Add a subtle glow effect 
            CTX.shadowBlur = 10;
            CTX.shadowColor = this.color;
            
            CTX.fillRect(this.x - 1, this.y - 5, 2, 10);
            
            CTX.shadowBlur = 0; // Reset shadow for other objects
        }
    }

    /** Represents the user's controllable ship. */
    class Player extends GameObject {
        constructor(x, y) {
            super(x, y, 15, 'white'); // White ship for B&W theme
            this.speed = 250; // pixels per second
        }

        /**
         * Updates the player's position based on input keys and constraints.
         * @param dt Delta time (time elapsed since last frame) in seconds.
         */
        update(dt) {
            if (game.keys.left) {
                this.x -= this.speed * dt;
            }
            if (game.keys.right) {
                this.x += this.speed * dt;
            }

            // Keep player within horizontal bounds
            this.x = Math.max(this.radius, Math.min(CANVAS.width - this.radius, this.x));
        }

        /** Draws the angular player ship. */
        draw() {
            CTX.fillStyle = this.color;
            CTX.beginPath();
            // Nose
            CTX.moveTo(this.x, this.y - this.radius);
            // Left wing
            CTX.lineTo(this.x - this.radius * 1.5, this.y + this.radius);
            // Right wing
            CTX.lineTo(this.x + this.radius * 1.5, this.y + this.radius);
            CTX.closePath();
            CTX.fill();

            // Draw cockpit/center (Gray)
            CTX.fillStyle = '#a1a1aa'; // Lighter gray
            CTX.beginPath();
            CTX.arc(this.x, this.y + 2, this.radius / 2, 0, Math.PI * 2);
            CTX.fill();
        }

        /** * Fires a laser shot, respecting the burst limit and cooldown. */
        shoot() {
            if (game.keys.burstCount >= game.keys.burstLimit || game.keys.burstCooldown > 0) {
                return;
            }

            game.keys.burstCount++;
            game.keys.burstCooldown = 0.03; // Short delay between burst shots
            const LASER_SPEED = 500;
            let vx, vy;

            if (game.keys.burstCount === 1) {
                // First shot: Perfectly straight up
                const straightAngle = degToRad(90); 
                vx = Math.cos(straightAngle) * LASER_SPEED; 
                vy = -Math.sin(straightAngle) * LASER_SPEED; 
            } else {
                // Subsequent shots (Burst): 80-degree spread for the 'shotgun' feel
                const START_ANGLE = degToRad(90 - 40); 
                const END_ANGLE = degToRad(90 + 40);   

                const angle = randomRange(START_ANGLE, END_ANGLE);
                vx = Math.cos(angle) * LASER_SPEED;
                vy = -Math.sin(angle) * LASER_SPEED;
            }

            game.lasers.push(new Laser(this.x, this.y - this.radius, vx, vy, 'white')); // White laser
        }
    }

    /** Represents an alien enemy ship, styled as a rounded pixel box. */
    class Enemy extends GameObject {
        constructor(x, y, vx, vy, is404) {
            // Radius of 7.4 for a 14.8px width, matching the snippet style
            super(x, y, 7.4, 'white'); 
            this.vx = vx;
            this.vy = vy;
            this.is404 = is404; // Is this one of the active '404' ships?
            this.borderRadius = 2; // Rounded corners

            // Set colors based on whether it is an active 404 ship or a passive grid ship
            if (this.is404) {
                // Darker fill for the active ships for clear contrast (e.g., 40% opacity)
                this.fillColor = 'rgba(255, 255, 255, 0.40)'; 
            } else {
                // Lighter, more transparent fill for the background grid (20% opacity as per snippet)
                this.fillColor = 'rgba(255, 255, 255, 0.20)'; 
            }
            this.outlineColor = 'rgba(255, 255, 255, 1)'; // Solid white outline for both
        }

        /**
         * Updates the enemy's position.
         * @param dt Delta time (time elapsed since last frame) in seconds.
         */
        update(dt) {
            // Only update position if the game has started (ships are only moving if they are 404 ships)
            if (game.isStarted && this.is404) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Simple bouncing off horizontal walls
                if (this.x - this.radius < 0 || this.x + this.radius > CANVAS.width) {
                    this.vx *= -1;
                }
            }
        }

        /** Draws the enemy object as a rounded square with a low-opacity fill and white border. */
        draw() {
            const size = this.radius * 2; // 14.8px
            const halfSize = this.radius; // 7.4px
            const cornerRadius = this.borderRadius; 

            // Define the rounded rectangle path
            CTX.beginPath();
            CTX.moveTo(this.x - halfSize + cornerRadius, this.y - halfSize); 
            CTX.lineTo(this.x + halfSize - cornerRadius, this.y - halfSize); 
            CTX.arcTo(this.x + halfSize, this.y - halfSize, this.x + halfSize, this.y - halfSize + cornerRadius, cornerRadius); // Top-right
            CTX.lineTo(this.x + halfSize, this.y + halfSize - cornerRadius);
            CTX.arcTo(this.x + halfSize, this.y + halfSize, this.x + halfSize - cornerRadius, this.y + halfSize, cornerRadius); // Bottom-right
            CTX.lineTo(this.x - halfSize + cornerRadius, this.y + halfSize);
            CTX.arcTo(this.x - halfSize, this.y + halfSize, this.x - halfSize, this.y + halfSize - cornerRadius, cornerRadius); // Bottom-left
            CTX.lineTo(this.x - halfSize, this.y - halfSize + cornerRadius);
            CTX.arcTo(this.x - halfSize, this.y - halfSize, this.x - halfSize + cornerRadius, this.y - halfSize, cornerRadius); // Top-left
            CTX.closePath();

            // 1. Draw Fill
            CTX.fillStyle = this.fillColor;
            CTX.fill();

            // 2. Draw Outline (Solid White)
            CTX.strokeStyle = this.outlineColor;
            CTX.lineWidth = 1;
            CTX.stroke(); 
        }

        /** Fires a slow, small laser directly at the player's current position. 
         * Only 404 ships should ever fire.
         */
        shoot() {
            if (!game.player || !this.is404) return; // Only 404 ships shoot

            const LASER_SPEED = randomRange(150, 200); 
            
            // Calculate the vector components (dx, dy) from the enemy to the player
            const dx = game.player.x - this.x;
            const dy = game.player.y - this.y;

            // Calculate the angle using Math.atan2
            const angle = Math.atan2(dy, dx);

            // Calculate velocity components
            const vx = Math.cos(angle) * LASER_SPEED;
            const vy = Math.sin(angle) * LASER_SPEED;

            game.enemyLasers.push(new Laser(this.x, this.y + this.radius, vx, vy, '#e5e5e5')); // Light gray laser
        }
    }

    /** Resets the game state and sets up the initial fleet formation. */
    function initializeGame() {
        game.score = 0;
        game.isStarted = false;
        game.isGameOver = false;
        game.lasers = [];
        game.enemies = [];
        game.enemyLasers = [];
        game.explosions = []; 
        game.keys = { left: false, right: false, space: false, isFiring: false, burstCount: 0, burstLimit: 10, burstCooldown: 0 };
        game.enemyGlobalShotTimer = 3; 
        game.activeEnemyCount = 0; // Reset active count

        // Set initial canvas size before placing objects
        resizeCanvas(); 

        // Place Player
        game.player = new Player(CANVAS.width / 2, CANVAS.height - 50);

        // --- Grid Generation with 404 Pattern ---
        const shipRadius = 7.4; // 14.8px width
        const spacingX = CANVAS.width / (COLS + 3); // 16 columns + 3 padding spaces
        const spacingY = 20; // Vertical spacing
        
        // Vertical Centering: Aim for 25% down from the top (upper quarter)
        const totalGridHeight = ROWS * spacingY;
        const gridCenterY = totalGridHeight / 2;
        const desiredScreenY = CANVAS.height * 0.25; 
        const startY = desiredScreenY - gridCenterY;

        
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const index = r * COLS + c;
                const is404Active = SHAPE_404_PATTERN[index] === 1;

                const x = spacingX * (c + 1.5); 
                const y = startY + spacingY * r;
                
                const enemy = new Enemy(x, y, 0, 0, is404Active);
                game.enemies.push(enemy);

                if (is404Active) {
                    game.activeEnemyCount++;
                }
            }
        }

        SCORE_DISPLAY.textContent = `Score: ${game.score}`;
        OVERLAY.style.display = 'flex';
        
        // Update the intro text for the 404 theme
        OVERLAY.innerHTML = `
            <h1 class="message-title">404: Ships Not Found</h1>
            <p class="message-text">The central command group has broken ranks. Eliminate the **active** ships to clear the error.</p>
            <div class="message-instructions">
                Use <span class="key-hint">SPACE</span> to start and shoot. Use <span class="key-hint">←</span> and <span class="key-hint">→</span> to move.
            </div>
            <p class="message-text" style="margin-top: 20px;">
                Press <span class="key-hint">SPACE</span> to Engage!
            </p>
        `;
        
        // Run draw once to show the initial static grid
        draw(); 
    }

    /** Starts the game, hides the overlay, and initiates enemy movement. */
    function startGame() {
        if (!game.isStarted) {
            game.isStarted = true;
            OVERLAY.style.display = 'none'; 

            // Start chaotic movement ("scurry and shoot") only for the active 404 ships
            game.enemies.forEach(enemy => {
                if (enemy.is404) {
                    // Give them an initial random push 
                    enemy.vx = randomRange(-80, 80); // Chaotic horizontal movement
                    enemy.vy = randomRange(30, 60);  // Vertical drift downwards
                }
            });

            game.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
    }

    /** Sets the game to the game over state and displays the final score. */
    function gameOver() {
        if (!game.isGameOver) {
            game.isGameOver = true;
            game.isStarted = false;

            // Update the overlay for Game Over
            OVERLAY.innerHTML = `
                <h1 class="message-title">SYSTEM FAILURE</h1>
                <p class="message-text">Final Score: ${game.score}. That's tough, bro. </p>
                <p class="message-text" style="margin-top: 20px;">
                    Press <span class="key-hint">SPACE</span> to Restart.
                </p>
            `;
            OVERLAY.style.display = 'flex';
        }
    }

    /**
     * Main update loop for game logic and physics.
     * @param dt Delta time in seconds.
     */
    function update(dt) {
        if (game.isGameOver || !game.isStarted) return;

        // Update Player
        if (game.player) {
            game.player.update(dt);
        }

        // Handle Player Burst Cooldown
        if (game.keys.burstCooldown > 0) {
            game.keys.burstCooldown -= dt;
            if (game.keys.burstCooldown <= 0) {
                game.keys.burstCooldown = 0;
            }
        }

        // Handle Player Shooting (Burst)
        if (game.keys.space && game.keys.burstCount < game.keys.burstLimit && game.keys.burstCooldown === 0 && game.player) {
            game.player.shoot();
        }

        // Reset burst count when space is released
        if (!game.keys.space) {
            game.keys.burstCount = 0;
        }

        // --- Global Enemy Shooting Logic (Only active 404 ships shoot) ---
        game.enemyGlobalShotTimer -= dt;

        if (game.activeEnemyCount > 0 && game.enemyGlobalShotTimer <= 0) {
            // Find only active 404 ships that can shoot
            const activeEnemies = game.enemies.filter(e => e.is404);

            if (activeEnemies.length > 0) {
                // Pick a random live active enemy to shoot
                const randomIndex = Math.floor(Math.random() * activeEnemies.length);
                const shootingEnemy = activeEnemies[randomIndex];

                // Make it shoot (will target player)
                shootingEnemy.shoot();

                // Reset the global timer for a new random delay (1.5 to 3 seconds)
                game.enemyGlobalShotTimer = randomRange(1.5, 3);
            }
        }

        // Update and filter entities
        game.lasers.forEach(laser => laser.update(dt));
        game.lasers = game.lasers.filter(l => l.y > -10 && l.x > -10 && l.x < CANVAS.width + 10);

        game.enemies.forEach(enemy => enemy.update(dt));
        // Enemies are removed if they leave the bottom of the screen
        game.enemies = game.enemies.filter(e => e.y < CANVAS.height + 20); 

        game.enemyLasers.forEach(laser => laser.update(dt));
        game.enemyLasers = game.enemyLasers.filter(l => l.y < CANVAS.height + 10 && l.x > -10 && l.x < CANVAS.width + 10);

        // Update and filter explosions
        game.explosions.forEach(e => e.update(dt));
        game.explosions = game.explosions.filter(e => !e.isFinished());

        // --- Collision Detection ---
        
        // 1. Player Laser vs Enemy Ships 
        for (let lIndex = game.lasers.length - 1; lIndex >= 0; lIndex--) {
            const laser = game.lasers[lIndex];
            for (let eIndex = game.enemies.length - 1; eIndex >= 0; eIndex--) {
                const enemy = game.enemies[eIndex];
                const distance = Math.hypot(laser.x - enemy.x, laser.y - enemy.y);
                if (distance < laser.radius + enemy.radius) {
                    // Collision: Add explosion at enemy position
                    game.explosions.push(new Explosion(enemy.x, enemy.y));

                    // Remove laser
                    game.lasers.splice(lIndex, 1);
                    
                    // Logic based on enemy type:
                    if (enemy.is404) {
                        game.activeEnemyCount--; // Decrement active count
                        game.score += 10;
                        SCORE_DISPLAY.textContent = `Score: ${game.score}`;
                    } else {
                        // Passive ships give less score
                        game.score += 1;
                        SCORE_DISPLAY.textContent = `Score: ${game.score}`;
                    }

                    // Remove enemy
                    game.enemies.splice(eIndex, 1);
                    break; // Laser is destroyed, move to the next laser
                }
            }
        }

        // Check for player loss conditions only if player exists
        if (game.player) {
            // 2. Enemy Laser vs Player Ship
            for (let lIndex = game.enemyLasers.length - 1; lIndex >= 0; lIndex--) {
                const laser = game.enemyLasers[lIndex];
                const distance = Math.hypot(laser.x - game.player.x, laser.y - game.player.y);
                if (distance < laser.radius + game.player.radius) {
                    game.explosions.push(new Explosion(game.player.x, game.player.y)); // Player explosion
                    gameOver();
                    return;
                }
            }

            // 3. Enemy Ship vs Player Ship (Direct Collision)
            for (const enemy of game.enemies) {
                const distance = Math.hypot(game.player.x - enemy.x, game.player.y - enemy.y);
                if (distance < game.player.radius + enemy.radius) {
                    game.explosions.push(new Explosion(game.player.x, game.player.y)); // Player explosion
                    game.explosions.push(new Explosion(enemy.x, enemy.y)); // Enemy explosion
                    gameOver();
                    return;
                }
            }
        }

        // Check if all active 404 enemies are destroyed (Win condition)
        if (game.activeEnemyCount === 0) {
            // Update the overlay for Win
            OVERLAY.innerHTML = `
                <h1 class="message-title">SYSTEM RESTORED</h1>
                <p class="message-text">Error 404 cleared. The remaining ships await orders. Final Score: ${game.score}. Big W!</p>
                <p class="message-text" style="margin-top: 20px;">
                    Press <span class="key-hint">SPACE</span> to Restart.
                </p>
            `;
            gameOver();
        }
    }

    /** Draws all game entities to the canvas. */
    function draw() {
        CTX.fillStyle = '#000000'; // Clear the canvas with black
        CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

        // Draw entities
        game.lasers.forEach(laser => laser.draw());
        game.enemies.forEach(enemy => enemy.draw());
        game.enemyLasers.forEach(laser => laser.draw());

        if (game.player) {
            game.player.draw();
        }
        
        // Draw explosions last so they overlay everything
        game.explosions.forEach(e => e.draw());
    }

    /** The main game loop driven by requestAnimationFrame. */
    function gameLoop(currentTime) {
        if (game.isGameOver) return;

        // Calculate Delta Time
        game.deltaTime = (currentTime - game.lastTime) / 1000;
        game.lastTime = currentTime;

        update(game.deltaTime);
        draw();

        requestAnimationFrame(gameLoop);
    }

    // --- Input Handling ---

    window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft') {
            game.keys.left = true;
        } else if (e.code === 'ArrowRight') {
            game.keys.right = true;
        } else if (e.code === 'Space') {
            e.preventDefault(); // Prevent page scroll
            // Only set space to true if the game hasn't started or is over, to allow the first shot/start
            if (game.isStarted && !game.isGameOver) {
                 game.keys.space = true;
            } else if (!game.isStarted && !game.isGameOver) {
                startGame();
            } else if (game.isGameOver) {
                // Restart logic
                initializeGame();
                startGame(); 
            }
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft') {
            game.keys.left = false;
        } else if (e.code === 'ArrowRight') {
            game.keys.right = false; 
        } else if (e.code === 'Space') {
            game.keys.space = false;
        }
    });

    // Initial setup on window load
    window.addEventListener('load', () => {
        initializeGame();
    });
</script>
</body>
</html>
